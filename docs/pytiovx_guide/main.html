<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PyTIOVX User Guide: PyTIOVX User Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<img src="ti_logo.gif">
<tr bgcolor="#CCCCCC"> 
      <td bgcolor="#FFFFFF">
        <hr align="left" noshade size="1">
      </td>
</tr>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li class="current"><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>PyTIOVX User Guide</h1><p>PyTIOVX Tool allows users to specify an OpenVX graph as Python code and use the PyTIOVX tool to generate C code with OpenVX APIs. Additionally, the PyTIOVX Tool allows users to generate an OpenVX extension kernel wrapper by specifying parameters of the kernel and setting relationships between these parameters. <br/>
<br/>
 'tiovx' is the python module that is used to specify OpenVX graph in a compact manner using predefined classes and objects. After specification of OpenVX graph using PyTIOVX APIs, it can be exported in various formats including C code, JPG image</p>
<dl class="user"><dt><b>Installation</b></dt><dd><ul>
<li>Install Python 3.5.2 or later (<a href="https://www.python.org/">https://www.python.org/</a>)<ul>
<li>To confirm "python" and "pip" are in your install path, type below <div class="fragment"><pre class="fragment">        python --version
        pip --version
</pre></div></li>
</ul>
</li>
<li>Install 'dot' tool provided as part of 'graphviz' (<a href="http://www.graphviz.org/">http://www.graphviz.org/</a>) <br/>
 'dot' is required to generated .JPG file for a OpenVX graph specification<ul>
<li>To confirm "dot" tool is in your install path, type <div class="fragment"><pre class="fragment">        dot -V
</pre></div></li>
</ul>
</li>
<li>Install 'tiovx' python module by executing below command at folder "&lt;tiovx install path&gt;/tools/PyTIOVX" <div class="fragment"><pre class="fragment">      sudo pip install -e .
</pre></div> Expected output, <div class="fragment"><pre class="fragment">      Obtaining file:///&lt;tiovx install path&gt;/tiovx/tools/PyTIOVX
      Installing collected packages: tiovx
        Running setup.py develop <span class="keywordflow">for</span> tiovx
      Successfully installed tiovx-0.1
</pre></div></li>
<li>Now tiovx python module can be imported and used in your python script by doing below, <div class="fragment"><pre class="fragment">      <span class="keyword">from</span> tiovx <span class="keyword">import</span> *
</pre></div></li>
</ul>
</dd></dl>
<dl class="user"><dt><b>Usage</b></dt><dd></dd></dl>
<ul>
<li>Both modes of the PyTIOVX Tool usage (use case and kernel generation) are run in identical fashion as described below</li>
<li>Describe your application graph or kernel wrapper using PyTIOVX APIs in a .py file. Execute the .py file by invoking python <div class="fragment"><pre class="fragment">      python my_use_case.py
</pre></div> Note: if the following error is observed, please run using the command "python3.5 my_use_case.py" <div class="fragment"><pre class="fragment">      Traceback (most recent call last):
          File <span class="stringliteral">&quot;kernel_generate_example.py&quot;</span>, line 6, <span class="keywordflow">in</span> &lt;module&gt;
              <span class="keyword">from</span> tiovx <span class="keyword">import</span> *
          File <span class="stringliteral">&quot;tiovx/__init__.py&quot;</span>, line 63, <span class="keywordflow">in</span> &lt;module&gt;
              <span class="keyword">from</span> .enums <span class="keyword">import</span> *
          File <span class="stringliteral">&quot;tiovx/tools/PyTIOVX/tiovx/enums.py&quot;</span>, line 62, <span class="keywordflow">in</span> &lt;module&gt;
              <span class="keyword">from</span> enum <span class="keyword">import</span> Enum
      ImportError: No module named enum
</pre></div></li>
<li>See also examples in TIOVX tutorial <a href="../tutorial_guide/index.html" target="_blank">[HTML]</a> for making OpenVX usecases using PyTIOVX tool</li>
<li>See also sample python scripts (*.py) @ "&lt;tiovx install path&gt;/tools/sample_use_cases" for additional examples</li>
</ul>
<dl class="user"><dt><b>Example Kernel Generation Python Script</b></dt><dd></dd></dl>
<ul>
<li>Below is an example of a Python script used for generating a custom Channel Extract kernel: <div class="fragment"><pre class="fragment">      <span class="keyword">from</span> tiovx <span class="keyword">import</span> *

      code = KernelExportCode(<span class="stringliteral">&quot;TI&quot;</span>, <span class="stringliteral">&quot;extvx&quot;</span>, <span class="stringliteral">&quot;ext1&quot;</span>, <span class="stringliteral">&quot;c66&quot;</span>, <span class="stringliteral">&quot;CUSTOM_KERNEL_PATH&quot;</span>)

      code.setCoreDirectory(<span class="stringliteral">&quot;c66&quot;</span>)

      kernel = Kernel(<span class="stringliteral">&quot;channel_extract&quot;</span>)

      kernel.setParameter(Type.IMAGE, Direction.INPUT, ParamState.REQUIRED, <span class="stringliteral">&quot;IN&quot;</span>, [<span class="stringliteral">&apos;VX_DF_IMAGE_U8&apos;</span>], do_map=<span class="keyword">False</span>, do_unmap=<span class="keyword">False</span>)
      kernel.setParameter(Type.ENUM, Direction.INPUT, ParamState.REQUIRED, <span class="stringliteral">&quot;CHANNEL&quot;</span>)
      kernel.setParameter(Type.IMAGE, Direction.OUTPUT, ParamState.REQUIRED, <span class="stringliteral">&quot;OUT&quot;</span>, [<span class="stringliteral">&apos;VX_DF_IMAGE_U8&apos;</span>])
      kernel.setParameterRelationship([<span class="stringliteral">&quot;INPUT&quot;</span>, <span class="stringliteral">&quot;OUTPUT&quot;</span>], [Attribute.Image.WIDTH, Attribute.Image.HEIGHT])

      kernel.setTarget(Target.DSP1)
      kernel.setTarget(Target.DSP2)

      code.export(kernel)
</pre></div></li>
</ul>
<ul>
<li>The constructor for the KernelExportCode API contains arguments that serve as the directory paths of the generated code. The first argument, "TI", is the company name and serves as the include subpath. The second argument, "extvx",serves as the include filename. The third argument, "ext1", is the intended module of the kernel. The fourth argument, "channel_extract" is the specific core that this kernel will run on. Finally, the fifth argument "CUSTOM_KERNEL_PATH" is the path where the output files will be exported to. (Note: this path must be set as an environment variable.)</li>
<li>Several dedicated API's are provided in the case that certain parameters of KernelExportCode must be changed during execution of the script. This examples shows one example, setCoreDirectory. This method can change the intended core by passing in a particular core as its only argument.</li>
<li>The constructor for the Kernel class contains as its only argument the name of the kernel to be created.</li>
<li>The above example shows a simple case of setting up parameters for a Channel Extract kernel. By using the setParameter method of the kernel class, the scripts creates a number of OpenVX data types as input and output parameters of the kernel. These parameters can be either required parameters of the kernel or optional parameters; in this case, all parameters are set to required. Additionally, the names and allowed data types of these parameters can be set as an argument to the setParameter method.</li>
<li>After setting all parameters via the setParameter method, relationships among these parameters can be set via the setParameterRelationship method. This method is designed to ouput code in the validation callback to verify equality between certain attributes of parameters of the kernel. This validation of parameters is important in order no run-time errors of the kernel. In this case, a relationship is set between the width and height of the "INPUT" and "OUTPUT" parameters. This will produce code in the kernel validate callback that queries these attributes and checks for equality between them.</li>
<li>The list of targets for the kernel to run on can be set via the setTarget API. This is designed to set all possible targets for the kernel. In this example, the target kernel is set to run on both DSP1 and DSP2.</li>
<li>After setting up all parameters and targets of the kernel, the kernel wrappers can be generated by running the export method.</li>
<li>Further documentation of the API's used for kernel code generation can be found <a href="modules.html" target="_blank">here</a></li>
</ul>
<dl class="user"><dt><b>Generated Kernel Code Overview</b></dt><dd></dd></dl>
<ul>
<li>This section describes the generated files based on the example given above.</li>
<li>Based on whether the code generation path is set to CUSTOM_KERNEL_PATH or CUSTOM_APPLICATION_PATH, the kernel files are generated in different locations.</li>
<li>The files that are generated the first time only are noted. <div class="fragment"><pre class="fragment">      &lt;CUSTOM_KERNEL_PATH&gt;/DEVELOPER_TODO.txt (generated first time only)
      &lt;CUSTOM_KERNEL_PATH&gt;/include/TI/extvx.h (generated first time only)
      &lt;CUSTOM_KERNEL_PATH&gt;/include/TI/extvx_kernels.h (generated first time only)
      &lt;CUSTOM_KERNEL_PATH&gt;/include/TI/extvx_nodes.h (generated first time only)
      &lt;CUSTOM_KERNEL_PATH&gt;/ext1/c66/concerto.mak (generated first time only)
      &lt;CUSTOM_KERNEL_PATH&gt;/ext1/c66/vx_channel_extract_target.c
      &lt;CUSTOM_KERNEL_PATH&gt;/ext1/c66/vx_kernels_ext1_target.c (generated first time only)
      &lt;CUSTOM_KERNEL_PATH&gt;/ext1/host/concerto.mak (generated first time only)
      &lt;CUSTOM_KERNEL_PATH&gt;/ext1/tivx_ext1_node_api.c (generated first time only)
      &lt;CUSTOM_KERNEL_PATH&gt;/ext1/host/vx_channel_extract_host.c
      &lt;CUSTOM_KERNEL_PATH&gt;/ext1/host/vx_kernels_ext1_host.c (generated first time only)
      &lt;CUSTOM_KERNEL_PATH&gt;/ext1/include/tivx_ext1_kernels.h (generated first time only)
      &lt;CUSTOM_KERNEL_PATH&gt;/ext1/include/tivx_kernel_channel_extract.h
      &lt;CUSTOM_KERNEL_PATH&gt;/ext1/test/concerto.mak (generated first time only)
      &lt;CUSTOM_KERNEL_PATH&gt;/ext1/test/test_main.h (generated first time only)
</pre></div></li>
<li>If the final argument was changed to CUSTOM_APPLICATION_PATH, the following files are produced: <div class="fragment"><pre class="fragment">      &lt;CUSTOM_APPLICATION_PATH&gt;/DEVELOPER_TODO.txt (generated first time only)
      &lt;CUSTOM_APPLICATION_PATH&gt;/concerto_inc.mak
      &lt;CUSTOM_APPLICATION_PATH&gt;/custom_tools_path.mak
      &lt;CUSTOM_APPLICATION_PATH&gt;/kernels/ext1/include/TI/extvx.h (generated first time only)
      &lt;CUSTOM_APPLICATION_PATH&gt;/kernels/ext1/include/TI/extvx_kernels.h (generated first time only)
      &lt;CUSTOM_APPLICATION_PATH&gt;/kernels/ext1/include/TI/extvx_nodes.h (generated first time only)
      &lt;CUSTOM_APPLICATION_PATH&gt;/kernels/ext1/c66/concerto.mak (generated first time only)
      &lt;CUSTOM_APPLICATION_PATH&gt;/kernels/ext1/c66/vx_channel_extract_target.c
      &lt;CUSTOM_APPLICATION_PATH&gt;/kernels/ext1/c66/vx_kernels_ext1_target.c (generated first time only)
      &lt;CUSTOM_APPLICATION_PATH&gt;/kernels/ext1/host/concerto.mak (generated first time only)
      &lt;CUSTOM_APPLICATION_PATH&gt;/kernels/ext1/tivx_ext1_node_api.c (generated first time only)
      &lt;CUSTOM_APPLICATION_PATH&gt;/kernels/ext1/host/vx_channel_extract_host.c
      &lt;CUSTOM_APPLICATION_PATH&gt;/kernels/ext1/host/vx_kernels_ext1_host.c (generated first time only)
      &lt;CUSTOM_APPLICATION_PATH&gt;/kernels/ext1/include/tivx_ext1_kernels.h (generated first time only)
      &lt;CUSTOM_APPLICATION_PATH&gt;/kernels/ext1/include/tivx_kernel_channel_extract.h
      &lt;CUSTOM_APPLICATION_PATH&gt;/kernels/ext1/test/concerto.mak (generated first time only)
      &lt;CUSTOM_APPLICATION_PATH&gt;/kernels/ext1/test/test_main.h (generated first time only)
</pre></div></li>
<li>As noted, the majority of the generated files are only generated once per kernel module. These files contain boilerplate code needed for registering/unregistering the new kernels and node creation.</li>
<li>In the case that the module already exists, code will simply be appended to the existing files rather than duplicating any previously generated files.</li>
</ul>
<dl class="user"><dt><b>Overview of Necessary Kernel Code Modifications</b></dt><dd></dd></dl>
<ul>
<li>In addition to the code generated by the python script, a text file called "DEVELOPER_TODO.txt" is generated that provides information regarding the changes to be made to the generated files.</li>
<li>The two files wherein most modifications will occur are the host and target kernel files. The files for the given example are listed below: <div class="fragment"><pre class="fragment">      &lt;CUSTOM_APPLICATION_PATH&gt;/kernels/ext1/c66/vx_channel_extract_target.c
      &lt;CUSTOM_APPLICATION_PATH&gt;/kernels/ext1/host/vx_channel_extract_host.c
</pre></div></li>
<li>The host kernel file must be modified in the following ways:<ul>
<li>Validate callback: Additional custom parameter checking may need to be added to the validate callback. The script will generate parameter checking for attributes of parameters that are equal. Additional checking beyond the scope of the script must be entered in manually by the user. For example, in the case of a kernel with a scaled output, the validate callback should verify that the output is dimensions are scaled properly from the input. This type of check will most likely first require querying a given kernel parameter as specified by the OpenVX API designated for querying the given parameter. At this point the value can be verified against a known quantity. This step of proper validation catches errors during the verification stage and is important within the context of OpenVX to ensure no errors during execution of the graph.</li>
<li>Initialize callback: Appropriate valid region padding values must be added to the initialize callback to support the UNDEFINED border mode in the case that the data type in question is an image. These values will be determined by whether or not the generated kernel contains a region-based operation. For example, in the case that the kernel in question is a 3x3 filter, the padding for the top, bottom, left and right will all be a value of '1'. In the case that no region-based operations are performed, these values can be set to '0'.</li>
</ul>
</li>
<li>The target kernel file must be modified in the following ways:<ul>
<li>Create callback: The create callback is run once upon verification of the graph and should include allocation of any required local memory buffers as well as any one time initialization required for the kernel.</li>
<li>Delete callback: The delete callback is run upon release of the graph and should include the freeing of local memory buffers that were allocated within the create callback as well as any deinitialization of parameters that were initialized in the create callback.</li>
<li>Process callback: The process callback is run upon each execution of the graph and should include a call to the kernel process function. For example, in the case of OpenVX core kernels, the process callback contains a call to the optimized VXLIB function that performs the operation of the kernel.</li>
<li>Control callback: The control callback is run upon a user command to the kernel at run-time. It should include the processing of this user command and the operation necessary to modify the operation of the kernel.</li>
</ul>
</li>
</ul>
<dl class="user"><dt><b>Example Use Case Generation Python Script</b></dt><dd></dd></dl>
<ul>
<li>In addition to generating kernel wrappers, the Python script also provides the ability to generate full use cases consisting of existing nodes. The Python script will generate all of the necessary OpenVX-related function calls at a fraction of the amount of code.</li>
<li>In addition to generating OpenVX code, the Python tool also has the ability to generate an image capturing the nodes and connections within the OpenVX graph. This allows the developer to better visualize the functionality of the graph.</li>
<li>Several examples are given as a part of the TIOVX release at the location tiovx/tools/sample_use_cases. Particularly, the file "uc_sample_05.py" gives an in-depth look at the extent of the tool by providing a superset of the data types as well as showing how a good portion of the nodes are called.</li>
<li>An example is given below of how to generate OpenVX code using the Python tool. This example consists of two nodes, a table lookup node and a convolution node. The next section will describe the generated OpenVX code from this example. <div class="fragment"><pre class="fragment">      <span class="keyword">from</span> tiovx <span class="keyword">import</span> *

      context = Context(<span class="stringliteral">&quot;uc_sample_07&quot;</span>)
      graph = Graph()

      img_in = Image(640, 480, DfImage.U8)
      img_out_lut = Image(640, 480, DfImage.U8)
      lut = Lut(Type.UINT8, 255)
      node_lut = NodeTableLookup(img_in, lut, img_out_lut);

      img_out_conv = Image(640, 480, DfImage.S16)

      conv = Convolution(3, 3)
      node_conv = NodeConvolve(img_out_lut, conv, img_out_conv, target=Target.DSP2);

      graph.add ( node_lut )
      graph.add ( node_conv )

      context.add ( graph )

      ExportImage(context).export()
      ExportCode(context).export()
</pre></div></li>
<li>Further documentation of the API's used for use case generation can be found <a href="modules.html" target="_blank">here</a></li>
</ul>
<dl class="user"><dt><b>Generated Use Case Code Overview</b></dt><dd></dd></dl>
<ul>
<li>The top-level function prototypes generated by the use case generation script can be seen below: <div class="fragment"><pre class="fragment">      vx_status uc_sample_07_create(uc_sample_07 usecase);
      vx_status uc_sample_07_delete(uc_sample_07 usecase);
      vx_status uc_sample_07_verify(uc_sample_07 usecase);
      vx_status uc_sample_07_run(uc_sample_07 usecase);
</pre></div></li>
<li>The functions listed above can be called from a main function in sequential order upon successful return in order to run the OpenVX graph. The create function simply allocates all memory and data objects for the graph and performs any necessary initialization. The verify function calls the vxVerifyGraph API to ensure that all parameters of the graph are correct. The run function simply executes the graph once upon each run. Finally, the delete function frees all memory and performs deinitialization. The tutorial provided at tiovx/tutorial provides sample code of how to link these functions to a main function.</li>
<li>The following code snippet shows the creation of the data used in the use case generation script. <div class="fragment"><pre class="fragment">      vx_status uc_sample_07_data_create(uc_sample_07 usecase)
      {
          vx_status status = VX_SUCCESS;

          vx_context context = usecase-&gt;context;

          <span class="keywordflow">if</span> (status == VX_SUCCESS)
          {
              usecase-&gt;image_1 = vxCreateImage(context, 640, 480, VX_DF_IMAGE_U8);
              <span class="keywordflow">if</span> (usecase-&gt;image_1 == NULL)
              {
                  status = VX_ERROR_NO_RESOURCES;
              }
              vxSetReferenceName( (vx_reference)usecase-&gt;image_1, <span class="stringliteral">&quot;image_1&quot;</span>);
          }
          <span class="keywordflow">if</span> (status == VX_SUCCESS)
          {
              usecase-&gt;lut_3 = vxCreateLUT(context, VX_TYPE_UINT8, 255);
              <span class="keywordflow">if</span> (usecase-&gt;lut_3 == NULL)
              {
                  status = VX_ERROR_NO_RESOURCES;
              }
          }
          <span class="keywordflow">if</span> (status == VX_SUCCESS)
          {
              usecase-&gt;image_2 = vxCreateImage(context, 640, 480, VX_DF_IMAGE_U8);
              <span class="keywordflow">if</span> (usecase-&gt;image_2 == NULL)
              {
                  status = VX_ERROR_NO_RESOURCES;
              }
              vxSetReferenceName( (vx_reference)usecase-&gt;image_2, <span class="stringliteral">&quot;image_2&quot;</span>);
          }
          <span class="keywordflow">if</span> (status == VX_SUCCESS)
          {
              usecase-&gt;convolution_6 = vxCreateConvolution(context, 3, 3);
              <span class="keywordflow">if</span> (usecase-&gt;convolution_6 == NULL)
              {
                  status = VX_ERROR_NO_RESOURCES;
              }
          }
          <span class="keywordflow">if</span> (status == VX_SUCCESS)
          {
              usecase-&gt;image_5 = vxCreateImage(context, 640, 480, VX_DF_IMAGE_S16);
              <span class="keywordflow">if</span> (usecase-&gt;image_5 == NULL)
              {
                  status = VX_ERROR_NO_RESOURCES;
              }
              vxSetReferenceName( (vx_reference)usecase-&gt;image_5, <span class="stringliteral">&quot;image_5&quot;</span>);
          }

          <span class="keywordflow">return</span> status;
      }
</pre></div></li>
<li>As the above code snippet indicates, the PyTIOVX use case generation tool encapsulates a large amount of OpenVX code in very few lines of Python code The OpenVX generated code also provides error checking in the event that the data objects were unable to be created. A corresponding delete function will release the data objects created during the create phase.</li>
<li>The following code snippet shows the functions used for creating the nodes corresponding to the use case generation script. <div class="fragment"><pre class="fragment">      static vx_node usecase_node_create_node_4 (
        vx_graph graph ,
        vx_image image_0 ,
        vx_lut lut_1 ,
        vx_image image_2 
        )
      {
          vx_node node = NULL;
          vx_reference params[] =
          {
                (vx_reference)image_0 ,
                (vx_reference)lut_1 ,
                (vx_reference)image_2 
          };
          node = tivxCreateNodeByKernelEnum(graph, VX_KERNEL_TABLE_LOOKUP, params, 3);

          <span class="keywordflow">return</span> node;
      }

      static vx_node usecase_node_create_node_7 (
        vx_graph graph ,
        vx_image image_0 ,
        vx_convolution convolution_1 ,
        vx_image image_2 
        )
      {
          vx_node node = NULL;
          vx_reference params[] =
          {
                (vx_reference)image_0 ,
                (vx_reference)convolution_1 ,
                (vx_reference)image_2 
          };
          node = tivxCreateNodeByKernelEnum(graph, VX_KERNEL_CUSTOM_CONVOLUTION, params, 3);

          <span class="keywordflow">return</span> node;
      }
</pre></div></li>
<li>As the above code snippet shows, the nodes for the use case are created by first passing the corresponding data objects to a function the creating the node by enum. This process is how any given node is created using the script.</li>
<li>The following code snippet shows the generated OpenVX code for the verification and run steps. <div class="fragment"><pre class="fragment">      vx_status uc_sample_07_graph_0_verify(uc_sample_07 usecase)
      {
          vx_status status = VX_SUCCESS;

          vx_graph graph = usecase-&gt;graph_0;

          <span class="keywordflow">if</span> (status == VX_SUCCESS)
          {
              status = vxVerifyGraph(graph);
          }

          <span class="keywordflow">return</span> status;
      }

      vx_status uc_sample_07_graph_0_run(uc_sample_07 usecase)
      {
          vx_status status = VX_SUCCESS;

          vx_graph graph = usecase-&gt;graph_0;

          <span class="keywordflow">if</span> (status == VX_SUCCESS)
          {
              status = vxProcessGraph(graph);
          }

          <span class="keywordflow">return</span> status;
      }
</pre></div></li>
<li>The code snippet above is generated for every use case. The first function simply performs verification on the graph and returns the status of verification. The second function runs the graph by executing vxProcessGraph. In the case that the use case requires streaming, this function can be executed in a loop run continuously.</li>
<li>For further information on this use case, the entire file can be found at tiovx/tools/sample_use_cases/uc_sample_07.c.</li>
</ul>
<dl class="user"><dt><b>Using PyTIOVX to create a use case with a user kernel</b></dt><dd></dd></dl>
<ul>
<li>The PyTIOVX tool can also be used to generate use cases with user kernels as nodes of the graph. The following example describes the necessary steps in this process.</li>
<li>The following PyTIOVX script produces a simple user kernel wrapper with a single input image and a single output image. These images have equivalent widths heights and are set to run on both DSP1 and DSP2. In this example, the functionality of the kernel will be a simple copy from input to output. <div class="fragment"><pre class="fragment">      <span class="keyword">from</span> tiovx <span class="keyword">import</span> *

      code = KernelExportCode(<span class="stringliteral">&quot;TI&quot;</span>, <span class="stringliteral">&quot;presentation&quot;</span>, <span class="stringliteral">&quot;presentation_module&quot;</span>, <span class="stringliteral">&quot;c66x&quot;</span>, <span class="stringliteral">&quot;CUSTOM_KERNEL_PATH&quot;</span>)

      kernel = Kernel(<span class="stringliteral">&quot;presentation_example&quot;</span>)

      kernel.setParameter(Type.IMAGE, Direction.INPUT, ParamState.REQUIRED, <span class="stringliteral">&quot;IN&quot;</span>, [<span class="stringliteral">&apos;VX_DF_IMAGE_U8&apos;</span>])
      kernel.setParameter(Type.IMAGE, Direction.OUTPUT, ParamState.REQUIRED, <span class="stringliteral">&quot;OUT&quot;</span>, [<span class="stringliteral">&apos;VX_DF_IMAGE_U8&apos;</span>])
      kernel.setParameterRelationship([<span class="stringliteral">&quot;IN&quot;</span>, <span class="stringliteral">&quot;OUT&quot;</span>], [Attribute.Image.WIDTH, Attribute.Image.HEIGHT])

      kernel.setTarget(Target.DSP1)
      kernel.setTarget(Target.DSP2)

      code.export(kernel)
</pre></div></li>
<li>After running the previous script, the next step is to create a use case generation PyTIOVX script that includes the newly created user kernel. An example of this can be found at tiovx/tutorial/ch03_graph/vx_tutorial_graph_user_kernel_pytiovx_uc.py. Minimal modifications to this script are needed to incorporate the previously discussed user kernel. The first modification to be made is to change the name of the node to match the name given to the user kernel. In this case, the node name is NodePresentationExample. The next simple modification to be made is to replace the existing kernel string with the kernel string produced by the kernel generation script. In this case, the kernel string is "com.ti.presentation_module.presentation_example". Finally, slight modifications must be made to the checkParams method of the Node class based on the kernel parameters' relationships. The resulting PyTIOVX script can be seen below. <div class="fragment"><pre class="fragment">      <span class="keyword">from</span> tiovx <span class="keyword">import</span> *

      <span class="keyword">class </span>NodePresentationExample (Node) :
          <span class="keyword">def </span>__init__(self, image_in, image_out, name=&quot;default&quot;, target=Target.DEFAULT) :
              Node.__init__(self, <span class="stringliteral">&quot;com.ti.presentation_module.presentation_example&quot;</span>, image_in, image_out)
              self.setParams(1, 1, Type.IMAGE, Type.IMAGE)
              self.setTarget(target)
              self.setKernelEnumName(<span class="stringliteral">&quot;VX_USER_KERNEL&quot;</span>)

          <span class="keyword">def </span>checkParams(self, *param_type_args) :
              Node.checkParams(self, *param_type_args)
              <span class="keyword">assert</span> ( self.ref[0].width    == self.ref[1].width ), <span class="stringliteral">&quot;Input and Output width MUST match&quot;</span>
              <span class="keyword">assert</span> ( self.ref[0].height   == self.ref[1].height ), <span class="stringliteral">&quot;Input and Output height MUST match&quot;</span>
              <span class="keyword">assert</span> ( self.ref[0].df_image == self.ref[1].df_image ), <span class="stringliteral">&quot;Input data format and output data format must match&quot;</span>
              <span class="keyword">assert</span> ( self.ref[1].df_image == DfImage.U8 ), <span class="stringliteral">&quot;Data format must be U8&quot;</span>

      <span class="keyword">def </span>make_my_graph() :
          context = Context(<span class="stringliteral">&quot;uc_sample_08&quot;</span>)

          graph = Graph()

          width = 640
          height = 480

          in_image = Image(width, height, DfImage.U8, name=<span class="stringliteral">&quot;in&quot;</span>)

          out_image = Image(width, height, DfImage.U8, name=<span class="stringliteral">&quot;out&quot;</span>)

          graph.add ( NodePresentationExample(in_image, out_image, target=Target.DSP1) )

          context.add ( graph )

          ExportImage(context).export()
          ExportCode(context).export()

      make_my_graph()
</pre></div></li>
<li>Now that the use case code has been generated, the next step in the process of running the code is writing a wrapper for the create, verify, run and delete functions. This can be done in multiple ways; however, a simple way to begin incorporates the existing tutorial. The tutorial consists of several examples that are run out of a menu. The generated use case can be implemented as an additional example from the tutorial menu. This method is described below.</li>
<li>The first step in the process of integrating the example into the tutorial is to first write a simple wrapper for the top-level functions generated by PyTIOVX. The following code shows a sample wrapper for the example given above as well as a few print statements to show the status of each step. (Note: the function prototype for the below function was added to the generated header file.) <div class="fragment"><pre class="fragment">      void vx_tutorial_graph_uc_sample_08()
      {
          vx_status status;
          /**
           * - Define the data structure representing the generated OpenVX use-case code.
           *
           * This structure includes the context, data object, node, graph handles
           * <span class="keywordflow">for</span> the generated code.
           * \code
           */
          uc_sample_08_t uc;

          printf(<span class="stringliteral">&quot; uc_sample_08: Tutorial Started !!! \n&quot;</span>);

          status = uc_sample_08_create(&amp;uc);
          printf(<span class="stringliteral">&quot;create status = %d\n&quot;</span>, status);
          <span class="keywordflow">if</span>(status==VX_SUCCESS)
          {
              status = uc_sample_08_verify(&amp;uc);
          }
          printf(<span class="stringliteral">&quot;verify status = %d\n&quot;</span>, status);
          <span class="keywordflow">if</span>(status==VX_SUCCESS)
          {
              status = uc_sample_08_run(&amp;uc);
          }
          printf(<span class="stringliteral">&quot;run status = %d\n&quot;</span>, status);
          <span class="keywordflow">if</span>(status==VX_SUCCESS)
          {
              status = uc_sample_08_delete(&amp;uc);
          }
          printf(<span class="stringliteral">&quot;delete status = %d\n&quot;</span>, status);
          printf(<span class="stringliteral">&quot; uc_sample_08: Tutorial Done !!! \n&quot;</span>);
          printf(<span class="stringliteral">&quot; \n&quot;</span>);
      }
</pre></div></li>
<li>The next step to add the use case to the tutorial menu is to make modifications to the tutorial file itself in order to call the wrapper shown above. This file can be found at tiovx/tutorial/ch03_graph/vx_tutorial_graph.c. The first modification involves simply calling the kernel wrapper by adding an additional case to the case statement for calling examples. The code for this step can be seen below: <div class="fragment"><pre class="fragment">      case <span class="stringliteral">&apos;8&apos;</span>:
          vx_tutorial_graph_uc_sample_08();
          <span class="keywordflow">break</span>;
</pre></div></li>
<li>The only additional change that must be added to this file is to add the include path to the use case header file. The necessary include path can be found below: <div class="fragment"><pre class="fragment">      <span class="comment">#include &lt;ch03_graph/uc_sample_08.h&gt;</span>
</pre></div></li>
<li>In order for the use case file to be built, this file must be added to the sources found in the file tiovx/tutorial/concerto.mak. This can be seen below: <div class="fragment"><pre class="fragment">      CH03_SOURCES := \
        ch03_graph/vx_tutorial_graph.c \
        ch03_graph/vx_tutorial_graph_image_gradients.c \
        ch03_graph/vx_tutorial_graph_image_gradients_pytiovx.c \
        ch03_graph/vx_tutorial_graph_image_gradients_pytiovx_uc.c \
        ch03_graph/vx_tutorial_graph_user_kernel.c \
        ch03_graph/phase_rgb_user_kernel.c \
        ch03_graph/vx_tutorial_graph_user_kernel_pytiovx.c \
        ch03_graph/vx_tutorial_graph_user_kernel_pytiovx_uc.c \
        ch03_graph/uc_sample_08.c \
</pre></div></li>
<li>Now that the use case has been added to the tutorial menu, there are only a few additional modifications to be made to get the use case running. The first is a modification to the concerto_inc.mak file in order to add the appropriate STATIC_LIBS. In this example, the CUSTOM_KERNEL_PATH was set to be the tiovx/kernels path. Therefore, in this case, the concerto_inc.mak file was located at tiovx/kernels/concerto_inc.mak. The additions to this file can be seen below: <div class="fragment"><pre class="fragment">      STATIC_LIBS += vx_kernels_presentation_module
      STATIC_LIBS += vx_target_kernels_c66x
</pre></div></li>
<li>The next modification to be made is to load kernel module that was created. This must be done after the context has been created. In this example, the kernel module can be loaded within the generated use case file "uc_sample_08.c", specifically in the uc_sample_08_create function. This full function can be seen below. The only line that was added to the generated code is the line calling the function "tivxPresentationModuleLoadKernels". <div class="fragment"><pre class="fragment">      vx_status uc_sample_08_create(uc_sample_08 usecase)
      {
          vx_status status = VX_SUCCESS;

          memset(usecase, 0, sizeof(uc_sample_08_t));

          <span class="keywordflow">if</span> (status == VX_SUCCESS)
          {
              usecase-&gt;context = vxCreateContext();
              <span class="keywordflow">if</span> (usecase-&gt;context == NULL)
              {
                  status = VX_ERROR_NO_RESOURCES;
              }
          }
          tivxPresentationModuleLoadKernels(usecase-&gt;context);
          <span class="keywordflow">if</span> (status == VX_SUCCESS)
          {
              status = uc_sample_08_data_create(usecase);
          }
          <span class="keywordflow">if</span> (status == VX_SUCCESS)
          {
              status = uc_sample_08_graph_0_create(usecase);
          }

          <span class="keywordflow">return</span> status;
      }
</pre></div></li>
<li>Additionally, within the use case file, the header file to the new kernel module must be included. The include file needed in this example can be seen below: <div class="fragment"><pre class="fragment">      <span class="comment">#include &lt;TI/presentation.h&gt;</span>
</pre></div></li>
<li>The next modification needed to be made is to add the functionality to the kernel by adding to the kernel process function. In this instance, a simple copy is needed in the kernel processing function. The code being used to perform the copy can be seen below: <div class="fragment"><pre class="fragment">       uint8_t *src_addr, *dst_addr;
       VXLIB_bufParams2D_t vxlib_src, vxlib_dst;
       tivxSetPointerLocation(in_desc, &amp;src_addr);
       tivxSetPointerLocation(out_desc, &amp;dst_addr);

       tivxInitBufParams(in_desc, &amp;vxlib_src);
       tivxInitBufParams(out_desc, &amp;vxlib_dst);

       memcpy(dst_addr, src_addr, vxlib_src.stride_y*vxlib_src.dim_y);
</pre></div></li>
<li>As the code above shows, a simple memcpy function is being used to copy the source image to the destination image. Additionally, a few helper functions are being used to extract information from the object descriptor data structures. First, the tivxSetPointerLocation helper function takes as an input an image object descriptor as well as a uint8_t pointer. This function will set the pointer to the beginning address of the image with the valid region taken into account. Additionally, the tivxInitBufParams is used to extract the image dimensions from the image object descriptor. This function populates the VXLIB_bufParams2D_t data structure which contains the X and Y dimensions, the Y stride and the data type of the image.</li>
<li>Note: will calling the register presentation module with the correct core be needed or will this be fixed?</li>
</ul>
<p><br/>
 <hr/>
<dl class="user"><dt><b>Disclaimer</b></dt><dd></dd></dl>
<p>See also <a class="el" href="TI_DISCLAIMER.html">TI Disclaimer</a>. </p>
</div>

<html>
<table bordercolor="#FFFFFF" bgcolor="#FFFFFF" width="100%">
<tr bgcolor="#CCCCCC">
      <td bgcolor="#FFFFFF">
        <hr align="left" noshade size="1">
      </td>
</tr>
<tr bgcolor="#CCCCCC">
      <td bgcolor="#FFFFFF"><font face="Verdana, Arial, Helvetica, sans-serif" size="1" color="#000000"><b><i>
        &copy Copyright 2017 Texas Instruments Incorporated. All rights reserved. </i></b></font></td>
</tr>
<tr bgcolor="#CCCCCC">
      <td bgcolor="#FFFFFF"><font face="Verdana, Arial, Helvetica, sans-serif" size="1" color="#000000">
        Document generated by <b><i> doxygen </i></b> 1.6.1
  </font></td>
</tr>
</table>
